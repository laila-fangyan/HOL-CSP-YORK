\<comment>\<open> ********************************************************************
 * This file is to automate the verification of deadlock freedom.
 * This version combines the lemmas in DeadlockFreenessStuff by Benoit and lemmas in Bounded_Buffer_211124_ddf_automation_incomplete by Simon.
 * 03 Feb 2025

 * updated due to DeadlockFreenessStuff.thy update by Benoit
 * 25 Feb 2025

*******************************************************************\<close>
theory DeadlockFreedom_Automation_benoit
  imports "HOL-CSP_OpSem.OpSem_Deadlock_Results" "Guard"
begin

(**)

lemma prefix_proving_Mndetprefix_ref :
  \<open>A \<subseteq> B \<Longrightarrow> A \<noteq> {} \<Longrightarrow> (\<And>a. a \<in> A \<Longrightarrow> P a \<sqsubseteq>\<^sub>F\<^sub>D Q a) \<Longrightarrow> (\<sqinter>a \<in> B \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D (\<sqinter>a \<in> A \<rightarrow> Q a)\<close>
  \<open>A \<subseteq> B \<Longrightarrow> A \<noteq> {} \<Longrightarrow> (\<And>a. a \<in> A \<Longrightarrow> P a \<sqsubseteq>\<^sub>F\<^sub>D Q a) \<Longrightarrow> (\<sqinter>a \<in> B \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D (\<box>a \<in> A \<rightarrow> Q a)\<close>
  \<open>a \<in> B \<Longrightarrow> P a \<sqsubseteq>\<^sub>F\<^sub>D R \<Longrightarrow> (\<sqinter>a \<in> B \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D a \<rightarrow> R\<close>
  apply (metis Mndetprefix_FD_subset mono_Mndetprefix_FD order_trans)
  apply (metis Mndetprefix_FD_Mprefix Mndetprefix_FD_subset mono_Mndetprefix_FD order.trans)
  by (meson Mndetprefix_FD_write0 dual_order.trans mono_write0_FD)

thm Mndetprefix_def

lemma read_proving_Mndetprefix_ref :
  \<open>inj_on c A \<Longrightarrow> c ` A \<subseteq> B \<Longrightarrow> A \<noteq> {} \<Longrightarrow> (\<And>a. a \<in> A \<Longrightarrow> P (c a) \<sqsubseteq>\<^sub>F\<^sub>D Q a) \<Longrightarrow> (\<sqinter>a \<in> B \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D (c\<^bold>?a \<in> A \<rightarrow> Q a)\<close>
  and write_proving_Mndetprefix_ref : \<open>c a \<in> B \<Longrightarrow> P (c a) \<sqsubseteq>\<^sub>F\<^sub>D R \<Longrightarrow> (\<sqinter>a \<in> B \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D (c\<^bold>!a \<rightarrow> R)\<close>
  by (unfold read_def, rule prefix_proving_Mndetprefix_ref(2), auto)[1]
     (metis prefix_proving_Mndetprefix_ref(3) write0_def write_def)
 

lemmas prefix_proving_Mndetprefix_UNIV_ref = prefix_proving_Mndetprefix_ref[where B = UNIV, simplified]
   and read_proving_Mndetprefix_UNIV_ref = read_proving_Mndetprefix_ref[where B = UNIV, simplified]
   and write_proving_Mndetprefix_UNIV_ref = write_proving_Mndetprefix_ref[where B = UNIV, simplified]


(*if P's nondetprefix process is refined by Q AND R, then it is also refined by Q \<sqinter> R, Q \<box> R, Q  R*)
lemma binops_proving_Mndetprefix_ref :
  \<open>(\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D Q \<Longrightarrow> (\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D R \<Longrightarrow> (\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D Q \<sqinter> R\<close>
  \<open>(\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D Q \<Longrightarrow> (\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D R \<Longrightarrow> (\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D Q \<box> R\<close>
  \<open>(\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D Q \<Longrightarrow> (\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D R \<Longrightarrow> (\<sqinter>a \<in> A \<rightarrow> P a) \<sqsubseteq>\<^sub>F\<^sub>D Q \<rhd> R\<close>
  apply (simp add: FD_iff_eq_Ndet Ndet_assoc)
  apply (simp add: FD_iff_eq_Ndet Ndet_distrib_Det_left)
  by (metis Sliding_id mono_Sliding_FD)


(*The failure set of a process P that iterates i times over Mndetprefix 
A = {}, then no events can be chosen
 - iterating 0 time, Failures =  \<F> P
 - iterating >0 times, Failures = {(s, X). s = []}
A \<noteq> {},
  - iterating n<i times, Failures = (s, X) and 
    s consists only of events from A and
    at least one event is executable
  - after completing i times, Failures = (s @ t, X) and
    s has exactly i steps, and
    Failures depends on \<F> P
*)
lemma F_iterate_Mndetprefix :
  \<open>\<F> (iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>A \<rightarrow> X)\<cdot>P) =
   (if A = {} then if i = 0 then \<F> P else {(s, X). s = []} else
   {(s, X). set s \<subseteq> ev ` A \<and> length s < i \<and> (\<exists>a \<in> A. ev a \<notin> X)} \<union>
   {(s @ t, X)| s t X. set s \<subseteq> ev ` A \<and> length s = i \<and> (t, X) \<in> \<F> P})\<close>
  (is \<open>?lhs P i = (if A = {} then if i = 0 then \<F> P else {(s, X). s = []} else
                   ?rhs1 P i \<union> ?rhs2 P i)\<close>)
proof (split if_split, intro conjI impI)
  show \<open>A = {} \<Longrightarrow> ?lhs P i = (if i = 0 then \<F> P else {(s, X). s = []})\<close>
    by (cases i) (simp_all add: F_STOP)
next
  show \<open>?lhs P i = ?rhs1 P i \<union> ?rhs2 P i\<close> if \<open>A \<noteq> {}\<close>
  proof (induct i arbitrary: P)
    show \<open>?lhs P 0 = ?rhs1 P 0 \<union> ?rhs2 P 0\<close> for P by simp
  next
    fix i P assume * : \<open>?lhs P i = ?rhs1 P i \<union> ?rhs2 P i\<close> for P
    let ?tmp = \<open>{(s, X). set s \<subseteq> ev ` A \<and> length s = i \<and> (\<exists>a \<in> A. ev a \<notin> X)}\<close>
    have \<open>?lhs P (Suc i) = ?lhs (\<sqinter>a\<in>A \<rightarrow> P) i\<close>
      by (simp del: iterate_Suc add: iterate_Suc2)
    also from "*" have \<open>\<dots> = ?rhs1 (\<sqinter>a\<in>A \<rightarrow> P) i \<union> ?rhs2 (\<sqinter>a\<in>A \<rightarrow> P) i\<close> .
    also have \<open>\<dots> = ?rhs1 P (Suc i) \<union> ?rhs2 P (Suc i)\<close>
    proof -
      have \<open>?rhs2 (\<sqinter>a\<in>A \<rightarrow> P) i = ?rhs2 P (Suc i) \<union> ?tmp\<close>
      proof (intro subset_antisym subsetI)
        fix s_X assume \<open>s_X \<in> ?rhs2 (\<sqinter>a \<in> A \<rightarrow> P) i\<close>
        then obtain t u X
          where ** : \<open>s_X = (t @ u, X)\<close> \<open>set t \<subseteq> ev ` A\<close>
                    \<open>length t = i\<close> \<open>(u, X) \<in> \<F> (\<sqinter>a \<in> A \<rightarrow> P)\<close> by blast
        from "**"(4) consider a where \<open>a \<in> A\<close> \<open>u = []\<close> \<open>ev a \<notin> X\<close>
          | a u' where \<open>a \<in> A\<close> \<open>u = ev a # u'\<close> \<open>(u', X) \<in> \<F> P\<close>
          by (simp add: F_Mndetprefix write0_def F_Mprefix \<open>A \<noteq> {}\<close>) (metis list.collapse)
        thus \<open>s_X \<in> ?rhs2 P (Suc i) \<union> ?tmp\<close>
        proof cases
          show \<open>a \<in> A \<Longrightarrow> u = [] \<Longrightarrow> ev a \<notin> X \<Longrightarrow> s_X \<in> ?rhs2 P (Suc i) \<union> ?tmp\<close> for a
            using "**"(2) by (auto simp add: "**"(1, 3) subset_iff)
        next
          fix a u' assume \<open>a \<in> A\<close> \<open>u = ev a # u'\<close> \<open>(u', X) \<in> \<F> P\<close>
          hence \<open>set (t @ [ev a]) \<subseteq> ev ` A\<close> \<open>length (t @ [ev a]) = Suc i\<close>
                \<open>s_X = ((t @ [ev a]) @ u', X)\<close>
            by (simp_all add: "**"(1, 2, 3))
          with \<open>(u', X) \<in> \<F> P\<close> show \<open>s_X \<in> ?rhs2 P (Suc i) \<union> ?tmp\<close> by blast
        qed
      next
        fix s_X assume \<open>s_X \<in> ?rhs2 P (Suc i) \<union> ?tmp\<close>
        then consider t u X where \<open>s_X = (t @ u, X)\<close> \<open>set t \<subseteq> ev ` A\<close> \<open>length t = Suc i\<close> \<open>(u, X) \<in> \<F> P\<close>
          | s X a where \<open>s_X = (s, X)\<close> \<open>a \<in> A\<close> \<open>set s \<subseteq> ev ` A\<close> \<open>length s = i\<close> \<open>ev a \<notin> X\<close> by auto
        thus \<open>s_X \<in> ?rhs2 (\<sqinter>a \<in> A \<rightarrow> P) i\<close>
        proof cases
          fix t u X assume ** : \<open>s_X = (t @ u, X)\<close> \<open>set t \<subseteq> ev ` A\<close> \<open>length t = Suc i\<close> \<open>(u, X) \<in> \<F> P\<close>
          from "**"(2, 3) obtain a t' where \<open>a \<in> A\<close> \<open>t = t' @ [ev a]\<close> \<open>set t' \<subseteq> ev ` A\<close> \<open>length t' = i\<close>
            by (cases t rule: rev_cases) auto
          moreover from this(2) "**"(1) have \<open>s_X = (t' @ ev a # u, X)\<close> by simp
          moreover have \<open>(ev a # u, X) \<in> \<F> (\<sqinter>a\<in>A \<rightarrow> P)\<close>
            by (simp add: F_Mndetprefix write0_def F_Mprefix \<open>A \<noteq> {}\<close> "**"(4) \<open>a \<in> A\<close>)
          ultimately show \<open>s_X \<in> ?rhs2 (\<sqinter>a \<in> A \<rightarrow> P) i\<close> by blast
        next
          show \<open>\<lbrakk>s_X = (s, X); a \<in> A; set s \<subseteq> ev ` A; length s = i; ev a \<notin> X\<rbrakk>
                \<Longrightarrow> s_X \<in> ?rhs2 (\<sqinter>a \<in> A \<rightarrow> P) i\<close> for s X a
            by (auto simp add: F_Mndetprefix write0_def F_Mprefix)
        qed
      qed
      moreover have \<open>?rhs1 (\<sqinter>a\<in>A \<rightarrow> P) i \<union> ?tmp = ?rhs1 P (Suc i)\<close>by auto
      ultimately show \<open>?rhs1 (\<sqinter>a\<in>A \<rightarrow> P) i \<union> ?rhs2 (\<sqinter>a\<in>A \<rightarrow> P) i =
                       ?rhs1 P (Suc i) \<union> ?rhs2 P (Suc i)\<close> by auto
    qed
    finally show \<open>?lhs P (Suc i) = ?rhs1 P (Suc i) \<union> ?rhs2 P (Suc i)\<close> .
  qed
qed


corollary T_iterate_Mndetprefix :
  \<open>\<T> (iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>A \<rightarrow> X)\<cdot>P) =
   (if A = {} then if i = 0 then \<T> P else {[]}
    else {s. set s \<subseteq> ev ` A \<and> length s < i} \<union>
         {s @ t| s t. set s \<subseteq> ev ` A \<and> length s = i \<and> t \<in> \<T> P})\<close>
  unfolding set_eq_iff
  by (auto simp add: F_iterate_Mndetprefix T_F_spec[symmetric])


lemma D_iterate_Mndetprefix :
  \<open>\<D> (iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>A \<rightarrow> X)\<cdot>P) =
   (if A = {} then if i = 0 then \<D> P else {}
    else {s @ t| s t. set s \<subseteq> ev ` A \<and> length s = i \<and> t \<in> \<D> P})\<close>
  (is \<open>?lhs P i = (if A = {} then if i = 0 then \<D> P else {} else ?rhs P i)\<close>)
  for P :: \<open>('a, 'r) process\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k\<close>
proof (split if_split, intro conjI impI)
  show \<open>A = {} \<Longrightarrow> ?lhs P i = (if i = 0 then \<D> P else {})\<close>
    by (cases i) (simp_all add: D_STOP)
next
  show \<open>?lhs P i = ?rhs P i\<close> if \<open>A \<noteq> {}\<close>
  proof (induct i arbitrary: P)
    show \<open>?lhs P 0 = ?rhs P 0\<close> for P by simp
  next
    fix i P assume * : \<open>?lhs P i = ?rhs P i\<close> for P
    have \<open>?lhs P (Suc i) = ?lhs (\<sqinter>a \<in> A \<rightarrow> P) i\<close>
      by (simp del: iterate_Suc add: iterate_Suc2)
    also from "*" have \<open>\<dots> = ?rhs (\<sqinter>a \<in> A \<rightarrow> P) i\<close> .
    also have \<open>\<dots> = ?rhs P (Suc i)\<close>
    proof safe
      fix s t :: \<open>('a, 'r) trace\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k\<close> assume \<open>set s \<subseteq> ev ` A\<close> \<open>t \<in> \<D> (\<sqinter>a\<in>A \<rightarrow> P)\<close> \<open>i = length s\<close>
      from \<open>t \<in> \<D> (\<sqinter>a\<in>A \<rightarrow> P)\<close>
      obtain a t' where \<open>a \<in> A\<close> \<open>t = ev a # t'\<close> \<open>t' \<in> \<D> P\<close>
        by (auto simp add: D_Mndetprefix write0_def D_Mprefix \<open>A \<noteq> {}\<close>)
      from this(1, 2) have \<open>s @ t = (s @ [ev a]) @ t'\<close> \<open>set (s @ [ev a]) \<subseteq> ev ` A\<close>
                           \<open>length (s @ [ev a]) = Suc (length s)\<close>
        by (simp_all add: \<open>set s \<subseteq> ev ` A\<close>)
      with \<open>t' \<in> \<D> P\<close> show \<open>\<exists>s' t'. s @ t = s' @ t' \<and> set s' \<subseteq> ev ` A \<and>
                                     length s' = Suc (length s) \<and> t' \<in> \<D> P\<close> by blast
    next
      fix s t :: \<open>('a, 'r) trace\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k\<close>
      assume \<open>set s \<subseteq> ev ` A\<close> \<open>length s = Suc i\<close> \<open>t \<in> \<D> P\<close>
      from this(1, 2) obtain a s'
        where \<open>a \<in> A\<close> \<open>s = s' @ [ev a]\<close> \<open>set s' \<subseteq> ev ` A\<close> \<open>length s' = i\<close>
        by (cases s rule: rev_cases) auto
      from this(1, 2) \<open>t \<in> \<D> P\<close> have \<open>s @ t = s' @ ev a # t\<close> \<open>ev a # t \<in> \<D> (\<sqinter>a\<in>A \<rightarrow> P)\<close>
        by (simp_all add: D_Mndetprefix write0_def D_Mprefix \<open>A \<noteq> {}\<close>)
      with \<open>set s' \<subseteq> ev ` A\<close> \<open>length s' = i\<close> 
      show \<open>\<exists>s' t'. s @ t = s' @ t' \<and> set s' \<subseteq> ev ` A \<and>
                    length s' = i \<and> t' \<in> \<D> (\<sqinter>a\<in>A \<rightarrow> P)\<close> by blast
    qed
    finally show \<open>?lhs P (Suc i) = ?rhs P (Suc i)\<close> .
  qed
qed


lemma tickFree_iff_set_range_ev : \<open>tickFree s \<longleftrightarrow> set s \<subseteq> range ev\<close>
  by (metis (no_types, lifting) Hiding_tickFree empty_filter_conv image_mono list.set_map subset_code(1)
      tickFree_iff_is_map_ev top_greatest)

(*when A = UNIV, the failure set of a process P that iterates i times over Mndetprefix on A*)
corollary F_iterate_Mndetprefix_UNIV :
  \<open>\<F> (iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P) =
   {(s, X). tickFree s \<and> length s < i \<and> (\<exists>a. ev a \<notin> X)} \<union>
   {(s @ t, X) |s t X. tickFree s \<and> length s = i \<and> (t, X) \<in> \<F> P}\<close>
  by (simp add: F_iterate_Mndetprefix tickFree_iff_set_range_ev)

corollary T_iterate_Mndetprefix_UNIV :
  \<open>\<T> (iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P) =
   {s. tickFree s \<and> length s < i} \<union>
   {s @ t |s t. tickFree s \<and> length s = i \<and> t \<in> \<T> P}\<close>
  by (simp add: T_iterate_Mndetprefix tickFree_iff_set_range_ev)

corollary D_iterate_Mndetprefix_UNIV :
  \<open>\<D> (iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P) =
   {s @ t |s t. tickFree s \<and> length s = i \<and> t \<in> \<D> P}\<close>
  by (simp add: D_iterate_Mndetprefix tickFree_iff_set_range_ev)


(* TODO : find a better name *)


definition GlobalNdet_iterations :: \<open>('a, 'r) process\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k \<Rightarrow> ('a, 'r) process\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k\<close> (\<open>(_\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+)\<close> [1000] 999)
  where \<open>GlobalNdet_iterations P \<equiv> \<sqinter>i \<in> {0<..}. iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P\<close>
(*this extends iterate i indefinitely, allowing P to be prefixed by an arbitrary but finite number (>0) of Mndetprefix, with the number of iterations being Ndet*)


text \<open>This new operator, which uses the * syntax, says that we can perform 0 events and then behave as P. These two operators  ought to be linked together with some lemmas. 24Jan25\<close>

definition GlobalNdet_iterations' :: \<open>('a, 'r) process\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k \<Rightarrow> ('a, 'r) process\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k\<close> (\<open>(_\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*)\<close> [1000] 999)
  where \<open>GlobalNdet_iterations' P \<equiv> \<sqinter>i \<in> UNIV. iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P\<close>
  (* UNIV = {0..} *)


lemma GlobalNdet_iterations'_is_Ndet_GlobalNdet_iterations : \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* = P \<sqinter> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+\<close>
proof -
  have \<open>UNIV = insert (0 :: nat) {0<..}\<close> by fast
  have \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* = \<sqinter> i\<in>UNIV. iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P\<close>
    by (simp add: GlobalNdet_iterations'_def)
  also have \<open>\<dots> = iterate 0\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P \<sqinter>
                  (\<sqinter> i\<in>{0<..}. iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P)\<close>
    apply (subst \<open>UNIV = insert (0 :: nat) {0<..}\<close>)
    apply (subst GlobalNdet_distrib_unit)
    by simp_all
  also have \<open>iterate 0\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P = P\<close> by simp
  also have \<open>(\<sqinter> i\<in>{0<..}. iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P) = P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+\<close>
    by (simp add: GlobalNdet_iterations_def)
  finally show \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* = P \<sqinter> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+\<close> .
qed


lemma GlobalNdet_iterations'_Mndetprefix : \<open>(\<sqinter>a\<in>UNIV \<rightarrow>  P)\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* = P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+\<close>
proof -
  have \<open>(\<sqinter>a\<in>UNIV \<rightarrow>  P)\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* = (\<sqinter> i\<in>UNIV. iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>(\<sqinter>a\<in>UNIV \<rightarrow>  P))\<close>
    by (simp add: GlobalNdet_iterations'_def)
  also have \<open>\<dots> = \<sqinter> i\<in>UNIV. iterate (Suc i)\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P\<close>
    by (rule mono_GlobalNdet_eq) (simp del: iterate_Suc add: iterate_Suc2)
  also have \<open>\<dots> = \<sqinter> i\<in>{0<..}. iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P\<close>
    by (auto simp add: inj_on_mapping_over_GlobalNdet[of Suc UNIV, simplified]
        greaterThan_0 intro: mono_GlobalNdet_eq)
  also have \<open>\<dots> = P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+\<close> by (simp add: GlobalNdet_iterations_def)
  finally show \<open>(\<sqinter>a\<in>UNIV \<rightarrow>  P)\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* = P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+\<close> .
qed



lemma GlobalNdet_iterations_is_one_step_ahead_GlobalNdet_iterations' :\<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ = \<sqinter>a\<in>UNIV \<rightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*\<close>
proof (subst Process_eq_spec, safe)
  show \<open>t \<in> \<D> (P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+) \<Longrightarrow> t \<in> \<D> (\<sqinter>a\<in>UNIV \<rightarrow>  P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*)\<close> for t
    apply (simp add: D_Mndetprefix write0_def D_Mprefix)
    apply (simp add: GlobalNdet_iterations_def GlobalNdet_iterations'_def)
    apply (cases t, simp_all add:  D_GlobalNdet D_iterate_Mndetprefix_UNIV greaterThan_0)
    by (metis (no_types, lifting) append_eq_Cons_conv is_ev_def length_greater_0_conv
              tickFree_Cons_iff zero_less_Suc)
next
  show \<open>t \<in> \<D> (\<sqinter>a\<in>UNIV \<rightarrow>  P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*) \<Longrightarrow> t \<in> \<D> (P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+)\<close> for t
    apply (simp add: D_Mndetprefix write0_def D_Mprefix)
    apply (simp add: GlobalNdet_iterations_def GlobalNdet_iterations'_def)
    apply (cases t, simp_all add: D_GlobalNdet D_iterate_Mndetprefix_UNIV greaterThan_0)
    by (metis append_Cons event\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k.disc(1) length_Cons tickFree_Cons_iff)
next
  show \<open>(t, X) \<in> \<F> (P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+) \<Longrightarrow> (t, X) \<in> \<F> (\<sqinter>a\<in>UNIV \<rightarrow>  P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*)\<close> for t X
    apply (simp add: F_Mndetprefix write0_def F_Mprefix)
    apply (simp add: GlobalNdet_iterations_def GlobalNdet_iterations'_def)
    apply (simp add: F_GlobalNdet F_iterate_Mndetprefix_UNIV)
    apply (cases t, simp_all add: greaterThan_0 append_eq_Cons_conv is_ev_def)
    by (smt (verit, best) append_eq_Cons_conv is_ev_def length_greater_0_conv
            tickFree_Cons_iff zero_less_Suc)
next
  show \<open>(t, X) \<in> \<F> (\<sqinter>a\<in>UNIV \<rightarrow>  P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*) \<Longrightarrow> (t, X) \<in> \<F> (P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+)\<close> for t X
    apply (simp add: F_Mndetprefix write0_def F_Mprefix)
    apply (simp add: GlobalNdet_iterations_def GlobalNdet_iterations'_def)
    apply (simp add: F_GlobalNdet F_iterate_Mndetprefix_UNIV)
    apply (cases t, simp_all add: gt_ex greaterThan_0)
    by (meson Cons_eq_appendI event\<^sub>p\<^sub>t\<^sub>i\<^sub>c\<^sub>k.disc(1) length_Suc_conv tickFree_Cons_iff)
qed


text\<open>Benoit 30Jan, changed from \<open>\<sqinter>a\<in>UNIV \<rightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c*  \<sqsubseteq>\<^sub>F\<^sub>D Q \<Longrightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D Q\<close> to  \<longleftrightarrow>\<close>

lemma one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD :
  \<open>\<sqinter>a\<in>UNIV \<rightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*  \<sqsubseteq>\<^sub>F\<^sub>D Q \<longleftrightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D Q\<close>
  by (simp add: GlobalNdet_iterations_is_one_step_ahead_GlobalNdet_iterations')

text \<open>York: This law would allow us to break down the proof into an initial event step, followed by an arbitrary number  of steps. Then we could try and prove laws like the one below.
This means that if Q can do some number of events and then behave as P, then Q prefixed by a   can also do some number of steps and then behave as P. It seems to be intuitively true, but we  can't prove it. It would however avoid needing to pick the number of steps to make before
  recursing, which would facilitate fully automated proof.24Jan25
proved by Benoit 30Jan\<close>

lemma eat_lemma: \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D a \<rightarrow> Q\<close> if \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D Q\<close>
proof (rule trans_FD)
  show \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D \<sqinter>a\<in>UNIV \<rightarrow> Q\<close>
    apply (subst GlobalNdet_iterations'_is_Ndet_GlobalNdet_iterations)
    by (metis FD_iff_eq_Ndet GlobalNdet_iterations_is_one_step_ahead_GlobalNdet_iterations' Ndet_assoc mono_Mndetprefix_FD that)
  next
  show \<open>(\<sqinter>a\<in>UNIV \<rightarrow> Q) \<sqsubseteq>\<^sub>F\<^sub>D a \<rightarrow> Q\<close>
    by (simp add: prefix_proving_Mndetprefix_UNIV_ref(3))
qed




lemma iterate_F_imp_GlobalNdet_iterations_F :
  \<open>0 < i \<Longrightarrow> iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P \<sqsubseteq>\<^sub>F Q \<Longrightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F Q\<close>
  by (unfold GlobalNdet_iterations_def)
     (meson GlobalNdet_refine_F greaterThan_iff trans_F)

lemma iterate_T_imp_GlobalNdet_iterations_T :
  \<open>0 < i \<Longrightarrow> iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P \<sqsubseteq>\<^sub>T Q \<Longrightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>T Q\<close>
  by (unfold GlobalNdet_iterations_def)
     (meson GlobalNdet_refine_F greaterThan_iff leF_imp_leT trans_T)

lemma iterate_D_imp_GlobalNdet_iterations_D :
  \<open>0 < i \<Longrightarrow> iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P \<sqsubseteq>\<^sub>D Q \<Longrightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>D Q\<close>
  by (unfold GlobalNdet_iterations_def)
     (meson GlobalNdet_refine_FD greaterThan_iff leFD_imp_leD trans_D)

lemma iterate_FD_imp_GlobalNdet_iterations_FD :
  \<open>0 < i \<Longrightarrow> iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P \<sqsubseteq>\<^sub>F\<^sub>D Q \<Longrightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D Q\<close>
  by (metis iterate_D_imp_GlobalNdet_iterations_D
            iterate_F_imp_GlobalNdet_iterations_F
              leFD_imp_leD leFD_imp_leF leF_leD_imp_leFD)

lemma iterate_DT_imp_GlobalNdet_iterations_DT :
  \<open>0 < i \<Longrightarrow> iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P \<sqsubseteq>\<^sub>D\<^sub>T Q \<Longrightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>D\<^sub>T Q\<close>
  by (metis iterate_D_imp_GlobalNdet_iterations_D
            iterate_T_imp_GlobalNdet_iterations_T
            leDT_imp_leD leDT_imp_leT leD_leT_imp_leDT)



lemma GlobalNdet_iterations_F_imp_deadlock_free : \<open>deadlock_free P\<close> if \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F P\<close>
proof -
  have \<open>\<F> P \<subseteq> \<F> (P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+)\<close> by (meson failure_refine_def \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F P\<close>)
  also have \<open>\<dots> = (\<Union>i\<in>{0<..}. {(s, X). tickFree s \<and> length s < i \<and> (\<exists>a. ev a \<notin> X)} \<union>
                               {(s @ t, X)| s t X. tickFree s \<and> length s = i \<and> (t, X) \<in> \<F> P})\<close>
    by (simp add: GlobalNdet_iterations_def F_GlobalNdet F_iterate_Mndetprefix_UNIV)
  moreover have \<open>\<dots> = (\<Union>i. {(s, X). tickFree s \<and> length s < Suc i \<and> (\<exists>a. ev a \<notin> X)} \<union>
                       {(s @ t, X)| s t X. tickFree s \<and> length s = Suc i \<and> (t, X) \<in> \<F> P})\<close>
    find_theorems \<open>(\<Union>i \<in> ?S. ?f i) = (\<Union>i \<in> ?S'. ?f' i)\<close>
    (* TODO : find a better proof *)
    by safe (auto, metis length_greater_0_conv less_imp_Suc_add)
  moreover have \<open>(s, range ev) \<in> \<dots> \<Longrightarrow> False\<close> for s
  proof (induct s)
    case Nil
    then show ?case by simp
  next
    case (Cons e s)
    from Cons.prems obtain t u i
      where * : \<open>e # s = t @ u\<close> \<open>tickFree t\<close>
                \<open>length t = Suc i\<close> \<open>(u, range ev) \<in> \<F> P\<close> by blast
    from "*"(1, 2, 3) obtain a t'
      where ** : \<open>e = ev a\<close> \<open>t = ev a # t'\<close> \<open>s = t' @ u\<close> \<open>tickFree t'\<close> \<open>length t' = i\<close>
      by (cases t; simp add: tickFree_def) (metis "*"(2) is_ev_def tickFree_Cons_iff)
    hence \<open>(s, range ev) \<in> (\<Union>i. {a. case a of (s, X) \<Rightarrow> tickFree s \<and> length s < Suc i \<and> (\<exists>a. ev a \<notin> X)} \<union>
            {(s @ t, X) |s t X. tickFree s \<and> length s = Suc i \<and> (t, X) \<in> \<F> P})\<close>
      (* TODO: write a better proof *)
      by simp (metis (no_types, lifting) "*"(4) Cons.hyps Suc_pred calculation length_greater_0_conv self_append_conv2 subset_eq)
    thus False using Cons.hyps by linarith
  qed
  ultimately show \<open>deadlock_free P\<close>
    unfolding AfterExt.deadlock_free_is_right(2)
    by (metis (no_types, lifting) front_tickFree_nonempty_append_imp gr0_conv_Suc is_processT2_TR
        is_processT5_S7 length_0_conv length_Suc_conv less_irrefl subset_iff)
qed

lemma GlobalNdet_iterations_FD_imp_deadlock_free :
  \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D P \<Longrightarrow> deadlock_free P\<close>
  by (simp add: GlobalNdet_iterations_F_imp_deadlock_free leFD_imp_leF)



text \<open> York: This would be a useful lemma to have, because it would allow us to have an operator that simply does n event steps. 24Jan25
 proved by Benoit 30Jan, SKIP to Skip 25Feb\<close>
lemma iterate_is_iterate_SKIP_Seq :  \<open>iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P = iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>Skip \<^bold>; P\<close>
proof (induct i)
  show \<open>iterate 0\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P =
        iterate 0\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>Skip \<^bold>; P\<close> by simp
next
  fix i assume hyp : \<open>iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow> X)\<cdot>P = iterate i\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>Skip \<^bold>; P\<close>
  show \<open>iterate (Suc i)\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>P =
        iterate (Suc i)\<cdot>(\<Lambda> X. \<sqinter>a\<in>UNIV \<rightarrow>  X)\<cdot>Skip \<^bold>; P\<close>
    by (auto simp add: Mndetprefix_Seq intro: mono_Mndetprefix_eq hyp)
qed




text\<open>Benoit 30Jan\<close>
lemma GlobalNdet_iterations'_GlobalNdet_iterations' : \<open>(P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*)\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* = P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>*\<close>
  apply (simp add: Process_eq_spec GlobalNdet_iterations'_def
                   F_GlobalNdet D_GlobalNdet
                   F_iterate_Mndetprefix_UNIV D_iterate_Mndetprefix_UNIV)
  apply safe
        apply simp_all
        apply blast
       apply blast
      apply (metis append.assoc tickFree_append_iff)
     apply blast
     apply (metis append_self_conv2 non_tickFree_imp_not_Nil)
   apply (metis append.assoc tickFree_append_iff)
  using tickFree_Nil by blast


text\<open>Benoit 30Jan, the original is lemma \<open>(P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+)\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ = P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+\<close>\<close>
lemma GlobalNdet_iterations_GlobalNdet_iterations : \<open>(P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+)\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ = \<sqinter>a\<in>UNIV \<rightarrow> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+\<close>
  by (simp add: GlobalNdet_iterations_is_one_step_ahead_GlobalNdet_iterations'
                GlobalNdet_iterations'_Mndetprefix
                GlobalNdet_iterations'_GlobalNdet_iterations')




lemma \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D P\<close> if \<open>P = (a \<rightarrow> P) \<box> (b \<rightarrow> P)\<close>
  apply (rule trans_FD[OF _ iterate_FD_imp_GlobalNdet_iterations_FD[of \<open>Suc 0\<close> \<open>P\<close>]])
    apply simp_all
  apply (subst (2) \<open>P = (a \<rightarrow> P) \<box> (b \<rightarrow> P)\<close>)
  apply (subst Det_id[symmetric])
  apply (rule mono_Det_FD)
  by (simp add: prefix_proving_Mndetprefix_ref(3))+
  

thm mono_Det_FD

lemma \<open> P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D P \<Longrightarrow>  P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D a \<rightarrow> P\<close>
  apply (unfold write0_def)
  apply (rule trans_FD[OF _ iterate_FD_imp_GlobalNdet_iterations_FD[of \<open>Suc 0\<close> \<open>P\<close>]])
  by (simp_all add: prefix_proving_Mndetprefix_UNIV_ref(2))
      
lemma \<open>P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D P\<close> if \<open>P = (a \<rightarrow> b \<rightarrow> P)\<close>
  apply (rule trans_FD[OF _ iterate_FD_imp_GlobalNdet_iterations_FD[of \<open>Suc (Suc 0)\<close> \<open>P\<close>]])
    apply simp_all
  by (metis idem_FD prefix_proving_Mndetprefix_UNIV_ref(3) that)

thm prefix_proving_Mndetprefix_UNIV_ref(3)




text\<open>York 31Jan25:\<close>

lemma no_step_refine: "P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D P"
  by (simp add: GlobalNdet_iterations'_is_Ndet_GlobalNdet_iterations Ndet_FD_self_left)


(*
thm binops_proving_Mndetprefi*
lemma 
  assumes "\<sqinter>a\<in>UNIV \<rightarrow>  P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D Q" "\<sqinter>a\<in>UNIV \<rightarrow>  P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D R"
  shows "\<sqinter>a\<in>UNIV \<rightarrow>  P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D Q \<box> R"
  by (smt (verit) assms(1) assms(2) binops_proving_Mndetprefix_ref(2))*)

lemma df_step_intro:
  assumes P_def: "P = Q" "P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>+ \<sqsubseteq>\<^sub>F\<^sub>D Q"
  shows "deadlock_free P"
  apply (rule GlobalNdet_iterations_FD_imp_deadlock_free)
  apply (subst P_def)  back (* apply (subst (2) P_def) *)
  apply (simp add: assms(2))
  done

lemma ndet_prefix_ext_choice:(*this is added for P = d\<rightarrow>( (a \<rightarrow> b \<rightarrow> P) \<box> (b \<rightarrow> c \<rightarrow> P)) pattern: prefix of external choice*)
  assumes "P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D Q" "P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D R"
  shows "P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D Q \<box> R"
  by (metis mono_Det_FD Det_id assms(1) assms(2))



lemma guard_choice:(*this is added for P =  (a & (c\<rightarrow> P)) \<box> (b &  (c \<rightarrow> P)) pattern: prefix of external choice*)
  assumes "P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D (a \<^bold>&  Q)" "P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D (b \<^bold>&  R)"
  shows "P\<^sup>p\<^sup>r\<^sup>o\<^sup>c\<^sup>* \<sqsubseteq>\<^sub>F\<^sub>D (a  \<^bold>& Q) \<box> (b  \<^bold>&  R)"
  by (metis mono_Det_FD Det_id assms(1) assms(2))


text\<open>The method\<close>
method deadlock_free uses P_def =
  (rule df_step_intro[OF P_def],
   simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym],
   simp add: prefix_proving_Mndetprefix_UNIV_ref(3) eat_lemma no_step_refine 
             binops_proving_Mndetprefix_ref ndet_prefix_ext_choice)


text\<open>examples\<close>


lemma ex1_m:
  assumes P_def: \<open>P = (a \<rightarrow> b \<rightarrow> c \<rightarrow> d \<rightarrow> P)\<close>
  shows \<open>deadlock_free P\<close> 
  apply (rule GlobalNdet_iterations_FD_imp_deadlock_free)
  apply (subst P_def) back
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
  apply (rule prefix_proving_Mndetprefix_UNIV_ref(3))
  apply (rule eat_lemma)+
  apply (rule no_step_refine)
  done 

lemma ex1_m':
  assumes P_def: \<open>P = (a \<rightarrow> b \<rightarrow> c \<rightarrow> d \<rightarrow> P)\<close>
  shows \<open>deadlock_free P\<close> 
  apply (rule df_step_intro[OF P_def])
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD
[THEN sym])
  by (simp add: eat_lemma no_step_refine prefix_proving_Mndetprefix_UNIV_ref(3))(*through sledgehammer*)
 

lemma ex1_a:
  assumes P_def: \<open>P = (a \<rightarrow> b \<rightarrow> c \<rightarrow> d \<rightarrow> P)\<close>
  shows \<open>deadlock_free P\<close>
  by (deadlock_free P_def: P_def)

lemma ex2_m:
  assumes P_def: \<open>P = (a \<rightarrow> b \<rightarrow> P) \<box> (b \<rightarrow> c \<rightarrow> P)\<close>
  shows \<open>deadlock_free P\<close>
  apply (rule GlobalNdet_iterations_FD_imp_deadlock_free)
  apply (subst (2) P_def)
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
    apply (simp add: binops_proving_Mndetprefix_ref(2) eat_lemma 
                   no_step_refine prefix_proving_Mndetprefix_UNIV_ref(3) )
  done

lemma ex2_a:
  assumes P_def': \<open>P = (a \<rightarrow> b \<rightarrow> P) \<box> (b \<rightarrow> c \<rightarrow> P)\<close>
  shows \<open>deadlock_free P\<close>
  by (deadlock_free P_def: P_def')

lemma ex3_m:
  assumes P_def: \<open>P = d\<rightarrow>( (a \<rightarrow> b \<rightarrow> P) \<box> (b \<rightarrow> c \<rightarrow> P))\<close>
  shows \<open>deadlock_free P\<close>  
  apply (rule GlobalNdet_iterations_FD_imp_deadlock_free)
  apply (subst (2) P_def)
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
  apply (rule prefix_proving_Mndetprefix_UNIV_ref(3))
  apply (rule ndet_prefix_ext_choice)
   apply (rule eat_lemma)+
  apply (rule no_step_refine)
   apply (rule eat_lemma)+
  apply (rule no_step_refine)
  done


lemma ex3_m':
  assumes P_def: \<open>P = d\<rightarrow>( (a \<rightarrow> b \<rightarrow> P) \<box> (b \<rightarrow> c \<rightarrow> P))\<close>
  shows \<open>deadlock_free P\<close>  
  apply (rule GlobalNdet_iterations_FD_imp_deadlock_free)
  apply (subst (2) P_def)
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
  apply (simp add: eat_lemma ndet_prefix_ext_choice  no_step_refine prefix_proving_Mndetprefix_UNIV_ref(3) )
  done

lemma ex3_a:
  assumes P_def: \<open>P = e\<rightarrow>( (a \<rightarrow> b \<rightarrow> P) \<box> (b \<rightarrow> c \<rightarrow> P))\<close>
  shows \<open>deadlock_free P\<close>
by (deadlock_free P_def: P_def)



text\<open>lemmas from 'Bounded_Buffer_211124_ddf_automation_incomplete' by Simon\<close>

lemma Mndetprefix_trans_subset_FD : 
  \<open>A \<noteq> {} \<Longrightarrow> A \<subseteq> B \<Longrightarrow> (\<And>a. a \<in> A \<Longrightarrow> Q a \<sqsubseteq>\<^sub>F\<^sub>D P a) \<Longrightarrow>
   Mndetprefix B Q \<sqsubseteq>\<^sub>F\<^sub>D Mndetprefix A P\<close>
  by (simp add: prefix_proving_Mndetprefix_ref(1))

lemma Ndet_trans_Det_FD :\<open>P \<sqsubseteq>\<^sub>F\<^sub>D Q \<Longrightarrow> R \<sqsubseteq>\<^sub>F\<^sub>D S \<Longrightarrow> P \<sqinter> R \<sqsubseteq>\<^sub>F\<^sub>D Q \<box> S\<close>
  by (meson Ndet_FD_Det dual_order.trans mono_Det_FD)

find_theorems "(\<box>)" "(\<sqsubseteq>\<^sub>F\<^sub>D)"


lemma DF_guard_extchoice:  assumes "b \<Longrightarrow> DF UNIV \<sqsubseteq>\<^sub>F\<^sub>D Q" "c \<Longrightarrow> DF UNIV \<sqsubseteq>\<^sub>F\<^sub>D R" "b \<or> c"
  shows "DF UNIV \<sqsubseteq>\<^sub>F\<^sub>D (b \<^bold>& Q) \<box> (c \<^bold>& R)"
  by (metis (full_types) Det_STOP Det_commute Guard_False Guard_True assms deadlock_free_Det deadlock_free_def)

lemma refine_guarded_extchoice:   assumes "b \<or> c" "b \<Longrightarrow> \<sqinter>x\<in>UNIV \<rightarrow> X \<sqsubseteq>\<^sub>F\<^sub>D Q" "c \<Longrightarrow> \<sqinter>x\<in>UNIV \<rightarrow> X \<sqsubseteq>\<^sub>F\<^sub>D R"
  shows "\<sqinter>x\<in>UNIV \<rightarrow>  X \<sqsubseteq>\<^sub>F\<^sub>D (b \<^bold>& Q) \<box> (c \<^bold>& R)"
  by (metis Det_STOP Det_commute FD_iff_eq_Ndet Guard_def Ndet_trans_Det_FD assms idem_FD)

lemma extchoice_preguard: "(b \<or> c) \<^bold>& (b \<^bold>& Q) \<box> (c \<^bold>& R) = (b \<^bold>& Q) \<box> (c \<^bold>& R)"
  by (simp add: Guard_def)

lemma GlobalDet_is_STOP_iff : \<open>\<box>a \<in> A. P a = STOP \<longleftrightarrow> (\<forall>a \<in> A. P a = STOP)\<close>
  \<comment>\<open>Missing in the theory\<close>
  by (simp add: STOP_iff_T T_GlobalDet, safe, auto)


find_theorems \<open>Sup\<close> \<open>?a :: bool set\<close>

lemma MultiDet_preguard: "finite I \<Longrightarrow> (Sup (b ` I) \<^bold>& (\<box> i\<in>I. b (i) \<^bold>& (P i))) = (\<box> i\<in>I. b i \<^bold>& P i)"
  apply (induct arbitrary: b P rule: finite_induct)
   apply (auto simp add: Guard_def Det_is_STOP_iff GlobalDet_is_STOP_iff)
  by (metis (mono_tags, lifting) GlobalDet_factorization_union GlobalDet_unit STOP_Det
      insert_def singleton_conv)

lemma GlobalDet_preguard :
  \<comment>\<open>Without the assumption \<^term>\<open>finite I\<close>.\<close>
  \<open>(Sup (b ` I) \<^bold>& (\<box> i\<in>I. b (i) \<^bold>& (P i))) = \<box> i\<in>I. b i \<^bold>& P i\<close>
  by (auto intro: Process_eq_optimizedI
      simp add: Guard_def GlobalDet_projs STOP_projs
      split: if_split_asm)

lemma GlobalDet_preguard_bis :\<open>\<box>i \<in> I. b i \<^bold>& P i = \<box>i \<in> {i \<in> I. b i}. P i\<close>
proof -
  have \<open>{i \<in> I. b i} \<union> {i \<in> I. \<not> b i} = I\<close> by blast
  hence \<open>\<box> i\<in>I. b i \<^bold>& P i = (\<box>i \<in> {i \<in> I. b i}. b i \<^bold>& P i) \<box> (\<box>i \<in> {i \<in> I. \<not> b i}. b i \<^bold>& P i)\<close>
    by (simp add: GlobalDet_factorization_union)
  also have \<open>\<box>i \<in> {i \<in> I. b i}. b i \<^bold>& P i = \<box>i \<in> {i \<in> I. b i}. P i\<close>
    by (auto intro: mono_GlobalDet_eq)
  also have \<open>\<box>i \<in> {i \<in> I. \<not> b i}. b i \<^bold>& P i = STOP\<close>
    by (simp add: GlobalDet_is_STOP_iff)
  finally show \<open>\<box>i \<in> I. b i \<^bold>& P i = \<box>i \<in> {i \<in> I. b i}. P i\<close> by simp
qed






lemma generilized_refine_guarded_extchoice:
  assumes (* "finite I" *) \<open>\<exists>i\<in>I. b(i)\<close> \<open>\<And> i. \<lbrakk> i \<in> I; b(i) \<rbrakk> \<Longrightarrow> \<sqinter>a \<in> UNIV \<rightarrow> X \<sqsubseteq>\<^sub>F\<^sub>D P(i)\<close>
  shows \<open>\<sqinter>a \<in> UNIV \<rightarrow> X \<sqsubseteq>\<^sub>F\<^sub>D \<box> i\<in>I. b(i) \<^bold>& P(i)\<close>
proof (unfold GlobalDet_preguard_bis)
  have \<open>\<box>i \<in> {i \<in> I. b i}. \<sqinter>a \<in> UNIV \<rightarrow> X \<sqsubseteq>\<^sub>F\<^sub>D \<box>i \<in> {i \<in> I. b i}. P i\<close>
    by (auto intro: mono_GlobalDet_FD assms(2))
  also have \<open>\<box>i \<in> {i \<in> I. b i}. \<sqinter>a \<in> UNIV \<rightarrow> X = \<sqinter>a \<in> UNIV \<rightarrow> X\<close>
    apply (rule GlobalDet_id)
    using \<open>\<exists>i\<in>I. b(i)\<close> by blast
  finally show \<open>\<sqinter>a \<in> UNIV \<rightarrow> X \<sqsubseteq>\<^sub>F\<^sub>D \<box>i \<in> {i \<in> I. b i}. P i\<close> .
qed
text\<open>because we have this pattern on the RHS of the conclusion, we need to normalize the model to match the RHS pattern.\<close>
(* old proof
using assms proof (induct arbitrary:X rule:finite_induct)
  case empty
  then show ?case
    by simp
next
  case (insert x F)
  then show ?case
  proof -
    from insert have 1:"(\<box> i\<in>({x} \<union> F). b i \<^bold>& P i) = (b x \<^bold>& P x) \<box> (Sup (b ` F) \<^bold>& (\<box> i\<in>F. b i \<^bold>& P i))"
      sledgehammer
      by (smt (verit, ccfv_threshold) Guard_def GlobalDet_insert' MultiDet_is_STOP_iff Sup_bool_def True_in_image_Bex insert_is_Un)
    have 2:"\<sqinter>x\<in>UNIV \<rightarrow> X \<sqsubseteq>\<^sub>F\<^sub>D (b x \<^bold>& P x) \<box> (Sup (b ` F) \<^bold>& (\<box> i\<in>F. b i \<^bold>& P i))"
      apply (rule refine_guarded_extchoice, auto simp add: Sup_bool_def insert)
      using Sup_bool_def insert.prems(1) apply blast
      done
    thus ?thesis
      using "1" by fastforce
  qed
qed *)


lemma ex4_m:
  assumes P_def: \<open>P = ((x<(0::int)) \<^bold>& (a \<rightarrow> P)) \<box>(( x \<ge> 0) \<^bold>& (b \<rightarrow> P))\<close>
  shows \<open>deadlock_free P\<close>
  apply (rule df_step_intro[OF P_def])
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
  apply (rule refine_guarded_extchoice)
  apply auto
  apply (rule prefix_proving_Mndetprefix_UNIV_ref)
  apply (rule no_step_refine)  
  apply (rule prefix_proving_Mndetprefix_UNIV_ref)
  apply (rule no_step_refine)
  done

lemma ex4_m':
  assumes P_def: \<open>P = ((x<(0::int)) \<^bold>& (a \<rightarrow> P)) \<box>(( x \<ge> 0) \<^bold>& (b \<rightarrow> P))\<close>
  shows \<open>deadlock_free P\<close>
  apply (rule df_step_intro[OF P_def])
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
  apply (simp add: Guard_def no_step_refine prefix_proving_Mndetprefix_UNIV_ref(3) refine_guarded_extchoice)
  done


lemma ex4_m'':
  assumes P_def: \<open>P = ((x<(0::int)) \<^bold>& (a \<rightarrow> P)) \<box>(( x \<ge> 0) \<^bold>& (b \<rightarrow> P))\<close>
  shows \<open>deadlock_free P\<close>
  apply (rule df_step_intro[OF P_def])
  by (simp add: GlobalNdet_iterations_is_one_step_ahead_GlobalNdet_iterations' 
                Guard_def no_step_refine prefix_proving_Mndetprefix_UNIV_ref(3))
 (*also work using 
  by (auto intro!: refine_guarded_extchoice prefix_proving_Mndetprefix_UNIV_ref no_step_refine 
         simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
 *)
  


method deadlock_free_guard uses P_def =
  (rule df_step_intro[OF P_def]
  , simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym]
  prefix_proving_Mndetprefix_UNIV_ref(3) eat_lemma no_step_refine 
             binops_proving_Mndetprefix_ref ndet_prefix_ext_choice Guard_def )
(*refine_guarded_extchoice not needed*)
(*does not work if change the 2nd simp into auto intro!,  why? ? *)

method deadlock_free_guard'' uses P_def =
  (rule df_step_intro[OF P_def]
  ,auto intro!: eat_lemma refine_guarded_extchoice 
                prefix_proving_Mndetprefix_UNIV_ref no_step_refine  
simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
(*does not work for all examples*)


lemma ex1_a':
  assumes P_def: \<open>P = (a \<rightarrow> b \<rightarrow> c \<rightarrow> d \<rightarrow> P)\<close>
  shows \<open>deadlock_free P\<close>
  by (deadlock_free_guard P_def: P_def)


lemma ex2_a':
  assumes P_def': \<open>P = (a \<rightarrow> b \<rightarrow> P) \<box> (b \<rightarrow> c \<rightarrow> P)\<close>
  shows \<open>deadlock_free P\<close>
  by (deadlock_free_guard P_def: P_def')


lemma ex3_a':
  assumes P_def: \<open>P = d\<rightarrow>( (a \<rightarrow> b \<rightarrow> P) \<box> (b \<rightarrow> c \<rightarrow> P))\<close>
  shows \<open>deadlock_free P\<close>
by (deadlock_free_guard P_def: P_def)


lemma ex4_auto:
  assumes P_def: \<open>P = (x < (0::int)) \<^bold>& (a \<rightarrow> P) \<box>( x \<ge> 0) \<^bold>& (b \<rightarrow> P)\<close>
  shows \<open>deadlock_free P\<close>
  by (deadlock_free_guard P_def: P_def)



text\<open>guard extchoice generalization\<close>

lemma ex5:
  assumes P_def: \<open>P = \<box> i\<in>{0,1::int}. (if i = 0 then b \<^bold>& P else  c \<^bold>& Q)\<close> \<open>b \<or> c\<close>
  shows \<open>deadlock_free P\<close>

  apply (rule GlobalNdet_iterations_FD_imp_deadlock_free)
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
  apply (subst (2) P_def)
  apply (simp add: GlobalDet_distrib_unit_bis)
  oops



lemma 
  assumes P_def: \<open>P = e\<rightarrow>((x < (0::int)) \<^bold>& (a \<rightarrow> P)) \<box>(( x \<ge> 0) \<^bold>& (b \<rightarrow> P))\<close>
  shows \<open>deadlock_free P\<close>
  apply (rule GlobalNdet_iterations_FD_imp_deadlock_free)
  apply (simp add: one_step_ahead_GlobalNdet_iterations'_FD_iff_GlobalNdet_iterations_FD[THEN sym])
  apply (subst (2) P_def)
  apply (rule prefix_proving_Mndetprefix_UNIV_ref)
  apply (rule guard_choice)
 
  oops





term "b \<^bold>& P \<box> c \<^bold>& Q"

term "b \<^bold>& P "
term "\<box> i\<in>{0,1::int}. (if i = 0 then b \<^bold>& P else c \<^bold>& Q)"

lemma "\<box> i\<in>{0,1::nat}. (if i = 0 then P else Q) = P \<box> Q"
  by (simp add: GlobalDet_distrib_unit_bis)


lemma bi_extchoice_norm:
"\<box> i\<in>{0,1::nat}. (if i = 0 then b else c) \<^bold>&(if i = 0 then P else Q) = b \<^bold>& P \<box> c \<^bold>& Q"
  by (simp add: GlobalDet_distrib_unit_bis)

lemma bi_extchoice_norm':
"\<box> i\<in>{0..1::nat}. (if i = 0 then b(0) else c) \<^bold>&(if i = 0 then P(0) else Q) = b(0) \<^bold>& P(0) \<box> c \<^bold>& Q"
  by (metis (lifting) ext atLeastAtMost_singleton atMost_atLeast0 bi_extchoice_norm image_Suc_lessThan lessThan_Suc_atMost lessThan_Suc_eq_insert_0)

lemma generalized_bi_extchoice_norm':
"\<box> i\<in>{n::nat..n+1}. (if i = n then b(n) else c) \<^bold>&(if i = n then P(n) else Q) = b(n) \<^bold>& P(n) \<box> c \<^bold>& Q"
  proof (induction n)
  case 0
  then show ?case 




(*binary \<box>  normalization*)
lemma biextchoic_normalization:
"(\<box> i\<in>{0..n::nat}. b(i) \<^bold>& P(i)) \<box> c \<^bold>& Q 
       = (\<box> i\<in>{0..n+1}. (if i \<le> n then b(i) else c) \<^bold>& (if i \<le> n then P(i) else Q))"
(is \<open>?lhs n = ?rhs n\<close>)
proof (induction n)
  case 0
  then show ?case 
    apply auto
    apply (simp add:bi_extchoice_norm'[THEN sym])
    by (smt (verit, best) mono_GlobalDet_eq)
next
  case (Suc n)
  then show ?case 
     proof -
    have step1: "(\<box>  i\<in>{0..Suc n}. b(i)  \<^bold>&  P(i))\<box> c \<^bold>& Q 
                 = (\<box> i\<in>{0..n}. b(i) \<^bold>&  P(i)) \<box> (b(Suc n) \<^bold>&  P(Suc n)) \<box> (c \<^bold>& Q) "
      by (simp add: Det_commute GlobalDet_distrib_unit_bis atLeast0AtMost atMost_Suc)
    also have step2: "... = (\<box> i\<in>{0..n}. b(i) \<^bold>&  P(i))  \<box> (c \<^bold>& Q) \<box> (b(Suc n) \<^bold>&  P(Suc n))"
      by (metis (full_types) Det_assoc Det_commute)
    also have step3: "(\<box> i\<in>{0..(Suc n +1)}. (if i \<le> (Suc n) then b(i) else c) \<^bold>& (if i \<le> (Suc n) then P(i) else Q))
                      =  (\<box> i\<in>{0..(Suc n + 1)}. (if i \<le> n then b(i) else (if i= Suc n then b(Suc n) else c)) \<^bold>& (if i \<le>  n then P(i) else (if i=Suc n then P(Suc n) else  Q)))  "
      by (smt (verit, best) le_Suc_eq mono_GlobalDet_eq)
    also have step4: "... =  ((\<box> i\<in>{0..n::nat}. b(i) \<^bold>& P(i)) \<box> 
             ( \<box> i\<in>{(Suc n::nat)..((Suc n) + 1)}. (if i = (Suc n) then b(Suc n) else c) \<^bold>& (if i = (Suc n) then P(Suc n) else Q ) ) ) "
     
    
  then show ?thesis sorry
qed 




term "\<box> i\<in>I. b(i) \<^bold>& P(i)"


end